## Data Extraction Analysis Script for 6th June 2023 Shot Day.
## This script extracts the scattering signal from the IAW diagnostic
## Generated by: H. Poole

## Import necessary libraries
import os
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle
import peakutils
import cv2
from peakutils.plot import plot as pplot
import sys
import scipy.constants as cst
from pyhdf.SD import SD, SDC
from scipy.optimize import curve_fit
import sys
from matplotlib.colors import LogNorm

class Shot_information:
    """
    Sets up and manages experimental parameters for Thomson scattering analysis.

    This class initializes IAW spectrometer parameters and timing information based on 
    the experimental shot number. These values need to be provided by the user.

    Parameters
    ----------
    Shot_day : str
        Experimental shot day (eg 'OMEGA_Jun2023').
    Shot_number : int
        Experimental shot number.
    Diagnostic : str
        Type of diagnostic (default is 'IAW').
    """
    def __init__(self, Shot_day, Shot_number, Diagnostic='IAW'):
        self.Shot_day = Shot_day
        self.Shot_number = Shot_number
        self.Diagnostic = Diagnostic
        self.get_system_info()
        self.get_shot_info()

    def get_shot_info(self):
        """
        Provides timing and scattering signal information for a specific shot number. Most of this information can be found in 
        the shot log. The timing offsets and wavelength range is determined when first processing a new shot.
        
        Attributes
        ----------
        T0 : float
            Reference T0 time for the experiment (typically see D3He/TS timing) (ns).
        Probe_start : float
            Start time of the Thomson Scattering (TS) probe (ns).
        Probe_duration : float
            Duration of the TS probe (ns).
        Signal_time (list) : list
            Start and end times of the signal window, accounting for offsets (ns). 
        Signal_wavelength : list
            Wavelength range of the scattering signal window (nm). This range should cover more than just the scattering signal,
            as the window edges will be used for background removal.
        Number_first_fiducial_on_streak : int
            Index of the first timing fiducial visible on the streak image.
        
        Notes
        -----
        - If the shot number is not recognized, the method prints a message and exits the program.
        """
        ## This provides timing information for the specific shot
        ## Most of this information can be found on the shot log
        ## T0 (ns) = T0 for experiment (see D3He/TS timing). (ie looking for Timing acquisition = 0 ns)
        ## Probe_start (ns) = The start time of the TS probe
        ## Probe_duration (ns) = Duration of the TS probe
        ## start_offset (ns) = Timing offset in observed start of the signal on streak compared to Probe_start
        ## end_offset (ns) =
        ## Number_first_fiducial_on_streak = Number (out of 8) of the first timing fiducial (usually lower left points) that appears on the streak
        if self.Shot_number == 108610:
            self.T0 = 22.3
            self.Probe_start = 25
            self.Probe_duration = 1
            start_offset = -0.1
            end_offset = 0.15
            self.Signal_time = [self.Probe_start+start_offset, self.Probe_start+self.Probe_duration+end_offset]
            self.Signal_wavelength = [self.Probe_wavelength-1.25, self.Probe_wavelength+1]
            self.Number_first_fiducial_on_streak = 2
        elif self.Shot_number == 108611:
            self.T0 = 24.3
            self.Probe_start = 27
            self.Probe_duration = 1
            start_offset = -0.1
            end_offset = 0.25
            self.Signal_time = [self.Probe_start+start_offset, self.Probe_start+self.Probe_duration+end_offset]
            self.Signal_wavelength = [self.Probe_wavelength-1.25, self.Probe_wavelength+1]
            self.Number_first_fiducial_on_streak = 2
        elif self.Shot_number == 108613:
            self.T0 = 16.3
            self.Probe_start = 19
            self.Probe_duration = 1
            start_offset = -0.1
            end_offset = 0.15
            self.Signal_time = [self.Probe_start+start_offset, self.Probe_start+self.Probe_duration+end_offset]
            self.Signal_wavelength = [self.Probe_wavelength-1.25, self.Probe_wavelength+1]
            self.Number_first_fiducial_on_streak = 2
        elif self.Shot_number == 108614:
            self.T0 = 18.3
            self.Probe_start = 21
            self.Probe_duration = 1
            start_offset = 0.05
            end_offset = 0.2
            self.Signal_time = [self.Probe_start+start_offset, self.Probe_start+self.Probe_duration+end_offset]
            self.Signal_wavelength = [self.Probe_wavelength-1.25, self.Probe_wavelength+1]
            self.Number_first_fiducial_on_streak = 2
        elif self.Shot_number == 108615:
            self.T0 = 20.3
            self.Probe_start = 23
            self.Probe_duration = 1
            start_offset = -0.2
            end_offset = 0.45
            self.Signal_time = [self.Probe_start+start_offset, self.Probe_start+self.Probe_duration+end_offset]
            self.Signal_wavelength = [self.Probe_wavelength-1.25, self.Probe_wavelength+1]
            self.Number_first_fiducial_on_streak = 2
        elif self.Shot_number == 108616:
            self.T0 = 22.3
            self.Probe_start = 25
            self.Probe_duration = 1
            start_offset = 0.05
            end_offset = 0.175
            self.Signal_time = [self.Probe_start+start_offset, self.Probe_start+self.Probe_duration+end_offset]
            self.Signal_wavelength = [self.Probe_wavelength-1.25, self.Probe_wavelength+1]
            self.Number_first_fiducial_on_streak = 2
        elif self.Shot_number == 108617:
            self.T0 = 16.3
            self.Probe_start = 19
            self.Probe_duration = 1
            start_offset = -0.125
            end_offset = -0.025
            self.Signal_time = [self.Probe_start+start_offset, self.Probe_start+self.Probe_duration+end_offset]
            self.Signal_wavelength = [self.Probe_wavelength-1.25, self.Probe_wavelength+1]
            self.Number_first_fiducial_on_streak = 2
        elif self.Shot_number == 108618:
            ## This is the only OTS CH shot (ie subsonic) that worked on this shot day
            self.T0 = 26.5
            self.Probe_start = 28.5
            self.Probe_duration = 1
            start_offset = -0.125
            end_offset = 0.225
            self.Signal_time = [self.Probe_start+start_offset, self.Probe_start+self.Probe_duration+end_offset]
            self.Signal_wavelength = [self.Probe_wavelength-1.25, self.Probe_wavelength+1]
            self.Number_first_fiducial_on_streak = 1
        else:
            print(f'Information for shot {self.Shot_number} has not been provided')
            quit()

    def get_system_info(self):
        """
        Sets spectrometer system parameters and experimental constants.

        This method initializes attributes related to the spectrometer and diagnostic setup.
        Values are typically sourced from the shot log and are required for data extraction
        and analysis.

        Attributes
        ----------
        Probe_wavelength : float
            Wavelength of the probe laser (nm).
        Fiducial_separation : float
            Time separation between timing fiducials (ns).
        Streak_delay : float
            Delay time for the streak camera (ns).
        Temporal_resolution : float
            Effective temporal resolution of the system (ns). 
        Wavelength_per_pixel : float
            Wavelength change per pixel (nm/pixel). Provided by J. Katz.
        Wavelength_resolution : float
            Spectral resolution for IAW (nm). NB: I'm uncertain about this value, and it's therefore not currently used in the analysis!
        
        Notes
        -----
        - The `Temporal_resolution` is determined by the maximum of the streak camera's temporal resolution
          and the diagnostic's temporal resolution.
        - The `Streak_temporal_resolution` is a approximation (~ Streak_sweep_speed / 150) provided by J. Katz.
        - The `Diagnostic_temporal_resolution` is the temporal resolution of the diagnostic, set by the pulse front tilt, provided by J. Katz.
        """
        self.Probe_wavelength = 526.5 ## 2w wavelength

        self.Fiducial_separation = 0.548
        self.Streak_delay = 0.780 
        
        Streak_sweep_speed = 5
        Streak_temporal_resolution = Streak_sweep_speed / 150
        Diagnostic_temporal_resolution = 0.2
        self.Temporal_resolution = max(Streak_temporal_resolution, Diagnostic_temporal_resolution)

        self.Wavelength_per_pixel = -0.00686
        self.Wavelength_resolution = 0.05

class Fiducial_analysis:
    """
    Performs analysis on the timing fiducials.

    This class extracts timing information from the p510 HDF file and analyzes fiducial peaks in the streak camera image.
    It determines the absolute timing of the fiducials, calculates the time per pixel, and generates the time axis for the streak image.

    Parameters
    ----------
    Shot_info : Shot_information
        Instance containing shot and system parameters.
    Parent_loc : str
        Parent directory location for the shot data.
    Data_image : numpy.ndarray
        The processed streak camera image data.

    Notes
    -----
    - The code looks for the p510 file in the shot number folder under a subfolder p510. If this does not exists, either the file path 
    self.p510_file needs to be edited, or the file needs to be downloaded from the Shot Report.
    """
    def __init__(self, Shot_info, Parent_loc, Data_image):
        self.Shot_info = Shot_info
        self.Data_image = Data_image
        self.p510_file = os.path.join(Parent_loc.replace('IAW', 'p510'), f'p510_data_p510_data_{self.Shot_info.Shot_number}.hdf')
    
        self.get_p510_fiducial_info()
        self.get_fiducials_on_streak()
        self.Time_axis = self.get_time_axis()

    def get_p510_fiducial_info(self, plot=False):
        """
        Extracts and processes fiducial timing information from a p510 HDF file. This provides the absolute timing 
        of the timing fiducials.

        Parameters
        ----------
        plot : bool (optional)
            If True, plots the fiducial signal and highlights the first fiducial on streak. Defaults to False.

        Attributes
        ----------
            First_fiducial_time : float
                Timing of the first fiducial on the TS streak (ns).
        
        Notes
        -----
        - If the p510 file does not exist, an error will be raised.
        """
        ## Check if the file exists
        if not os.path.exists(self.p510_file):
            print(f"p510 file not found: {self.p510_file}")
            sys.exit(1)
        
        hdf = SD(self.p510_file, SDC.READ)
        
        Time_data = hdf.select('SUMMARY_DATA_TIME')
        Time = Time_data[:]*1e-3 # ns

        Fiducial_data = hdf.select('SUMMARY_DATA_FIDU')
        Fiducial_signal = np.abs(Fiducial_data[:])
        
        ## Find the fiducial peaks
        Indexes = peakutils.peak.indexes(Fiducial_signal, min_dist=3, thres=0.1)
        if self.Shot_info.Shot_number == 108614:
            ## This shot has a random peak before the fiducials ...
            First_fiducial = Indexes[self.Shot_info.Number_first_fiducial_on_streak]
        else:
            First_fiducial = Indexes[self.Shot_info.Number_first_fiducial_on_streak-1]
        ## Timing of first fiducial on the TS streak
        self.First_fiducial_time = Time[First_fiducial]
        
        if plot:
            plt.figure()
            plt.xlabel('Time (ns)')
            plt.xlim(-2, 6)
            plt.suptitle('Fiducial signal from p510 file')
            pplot(Time, Fiducial_signal, Indexes)
            plt.axvline(self.First_fiducial_time, linestyle='--', color='k', label='First fiducial on streak')
            plt.legend()

    def get_fiducials_on_streak(self, xy=(0, 40), width=1000, height=200, plot=False):
        """
        Identifies and analyzes fiducial peaks in a specified region of the streak camera image.

        This method extracts a subregion of the data image, sums the signal along the vertical axis to produce a 1D signal,
        and locates fiducial peaks using peak detection. It calculates the average separation between fiducials in pixels,
        determines the pixel position of the first fiducial, and computes the time per pixel based on known fiducial separation.
        Optionally, it can plot the fiducial region, the extracted signal, and the detected peaks for visual inspection.

        Parameters
        ----------
        xy : tuple of int, optional
            The (x, y) coordinates of the bottom-left corner of the region to analyze. Default is (0, 40).
        width : int, optional
            The width of the region to analyze in pixels. Default is 1000.
        height : int, optional
            The height of the region to analyze in pixels. Default is 200.
        plot : bool, optional
            If True, generates a plot showing the fiducial region, extracted signal, and detected peaks. Default is False.

        Attributes
        ----------
        First_fiducial_pixel : int
            Pixel position of the first detected fiducial on the TS streak.
        Time_per_pixel : float
            Time per pixel, calculated from the known fiducial timing separation and their average pixel separation (ns/pixel).
        """
        Fiducial_image = self.Data_image[xy[1]:xy[1]+height, xy[0]:xy[0]+width]
        Fiducial_signal = np.sum(Fiducial_image, axis=0)
        Fiducial_signal /= np.max(Fiducial_signal)
        Pixels = np.arange(len(Fiducial_signal))+xy[0]
        Indexes = peakutils.peak.indexes(Fiducial_signal, min_dist=50)
        Avg_fiducial_separation_pix = np.mean(np.diff(Indexes))

        self.First_fiducial_pixel = Pixels[Indexes[0]]
        self.Time_per_pixel = self.Shot_info.Fiducial_separation / Avg_fiducial_separation_pix

        if plot:
            fig, axs = plt.subplots(2, 1, figsize=(5, 8), height_ratios=[2, 1], sharex=True)
            axs[0].imshow(self.Data_image, norm=LogNorm(), cmap='inferno', origin='lower')
            box = Rectangle(xy, width, height, fill=False, color='white', linewidth=2, alpha=0.65, label='Fiducial region')
            axs[0].add_patch(box)
            axs[0].set_ylabel('Pixels')
            axs[1].plot(Pixels, Fiducial_signal, label='Fiducial Signal')
            axs[1].scatter(Pixels[Indexes], Fiducial_signal[Indexes], color='red', label='Peaks')
            axs[1].legend()
            axs[1].set_xlabel('Pixels')
            axs[1].set_ylabel('Signal')
            for ax in axs.flat:
                ax.axvline(self.First_fiducial_pixel, linestyle='--', color='k', label='First fiducial')
            leg0 = axs[0].legend(loc='upper right')
            axs[0].add_artist(leg0)
            plt.suptitle(f's{self.Shot_info.Shot_number} Fiducial Region')
        return

    def get_time_axis(self):
        """
        Generates the time axis on the streak camera image.

        This method uses the fiducial information to calculate the time axis of the streak camera. The time axis is first set
        by converting pixels to time, and aligning the first fiducial with the expected time from the p510 file. Lastly, the
        time axis is shifted from the experimental reference timing to the simulation timing by adding the shot's T0, and
        accounting for the inherent timing delay of the streak camera.

        Attributes
        ----------
        Time_axis : array
            Time axis of the streak camera (ns).
        """
        Pixel_axis = np.arange(self.Data_image.shape[1])
        Time_axis = Pixel_axis * self.Time_per_pixel + (self.First_fiducial_time-self.First_fiducial_pixel * self.Time_per_pixel)
        Time_axis += self.Shot_info.T0 + self.Shot_info.Streak_delay
        return Time_axis

class Data_calibration:
    """
    Performs calibration and extraction of wavelength and time axes from the raw data image.

    This class reads the HDF data file, applies background subtraction, and computes the wavelength and time axes
    using calibration information and fiducial analysis. It also provides visualization tools for inspecting the
    selected scattering region that will be used in subsequent analysis.

    Parameters
    ----------
    Shot_info : Shot_information
        Instance containing shot and system parameters.
    Parent_loc : str
        Parent directory location for the shot data.
    Data_file_loc : str
        Path to the HDF data file.
    Calibration_file_loc : str, optional
        Path to the calibration file for wavelength axis alignment.

    Attributes
    ----------
    Data_image : np.ndarray
        The processed data image with the pre-shot subtracted.
    Time_axis : np.ndarray
        The time axis of the streaked image (ns).
    Wavelength_axis : np.ndarray
        The wavelength axis of the streaked image (nm).
    Time_per_pixel : float
        Time per pixel, determined from fiducial analysis (ns/pixel).
    Probe_center : float
        Central wavelength of the spectrometer (nm).
    Probe_pix_loc : float
        Pixel location of the probe center from calibration (if available).
    """
    def __init__(self, Shot_info, Parent_loc, Data_file_loc, Calibration_file_loc=None):
        self.Shot_info = Shot_info
        self.Parent_loc = Parent_loc
        self.Data_file_loc = Data_file_loc
        self.Calibration_file_loc = Calibration_file_loc
        
        self.read_hdf(self.Data_file_loc)

        self.Fiducial_info = Fiducial_analysis(self.Shot_info, self.Parent_loc, self.Data_image)
        self.Time_per_pixel = self.Fiducial_info.Time_per_pixel
        self.Time_axis = self.Fiducial_info.Time_axis

        self.Wavelength_axis = self.get_wavelength_axis()

        self.illustrate_scattering_region()

    def read_hdf(self, File_loc, plot=False):
        """
        This function opens the specified HDF file, extracts the first data group, and retrieves the raw and pre-shot images.
        It subtracts the background (pre-shot) image from the raw image, sets negative values to zero, and normalizes the result.
        If `plot` is True, the processed image is displayed using matplotlib.

        Parameters
        ----------
        File_loc : str
            Path to the HDF file to be read.
        plot : bool, optional
            If True, displays a plot of the processed data image (default is False).

        Returns
        -------
        Probe_center : float
            Central wavelength of the spectrometer (nm).
        Data_image : numpy.ndarray
            The processed image data with background subtracted and negative values set to zero.
        """
        print(f"Reading HDF file: {File_loc}")
        hdf = SD(File_loc, SDC.READ)
        hdf_object = hdf.datasets()
        
        ## Get list of data groups stored in hdf file
        obj_groups = [k for k in hdf_object.keys()]
        print(f"\tData groups in HDF file: {obj_groups}")

        ## Extracting real data from the hdf
        data = hdf.select('Streak_array')
        data_array = np.array(data.get(), dtype=np.float64)
        data_attributes = data.attributes()
        self.Probe_center = data_attributes['CentralWavelength']

        ## Data image taken during shot
        raw_image = data_array[0]
        ## Background image taken prior to shot
        pre_shot = data_array[1]
        data_image = raw_image - pre_shot
        data_image[data_image < 0] = 0
        data_image = data_image - np.min(data_image)
        self.Data_image = data_image

        if plot:
            fig, axs = plt.subplots(figsize=(5, 4))
            im = axs.imshow(self.Data_image, cmap='inferno', origin='lower')
            plt.colorbar(im, ax=axs)
            axs.set_aspect('equal', adjustable='box')
            axs.invert_yaxis()
            axs.set_yticks([])
            axs.set_xticks([])
            plt.suptitle('s{} {}'.format(self.Shot_info.Shot_number, self.Shot_info.Diagnostic))
    
    def calibration_info(self):
        """
        Reads the calibration file and extracts the pixel location of the probe center.

        Attributes
        ----------
        Probe_pix_loc : float
            Pixel location of the probe center from the calibration images.

        Notes
        -----
        - If the probe pixel location is not found in the calibration file, a ValueError is raised.
        """
        with open(self.Calibration_file_loc, 'r') as f:
            lines = f.readlines()
        
        found_probe_pix_loc = False
        for line in lines:
            if 'Probe pixel location' in line:
                self.Probe_pix_loc = int(float(line.split('=')[1].strip()))
                found_probe_pix_loc = True
                break
        if not found_probe_pix_loc:
            raise ValueError(f"Probe pixel location not found in calibration file: {self.Calibration_file_loc}")

    def get_wavelength_axis(self):
        """
        Calculates and returns the wavelength axis for the data image.

        The wavelength axis is computed based on the pixel indices and the wavelength-per-pixel calibration.
        If a calibration file is provided, the method uses calibration information to determine the wavelength shift.
        Otherwise, it estimates the shift based on the probe center and image dimensions.

        Returns
        -------
        Wavelength_axis: np.ndarray
            Array representing the wavelength axis corresponding to the data image.
        """
        Pixel_axis = np.arange(self.Data_image.shape[0])
        Wavelength_axis = Pixel_axis * self.Shot_info.Wavelength_per_pixel

        if self.Calibration_file_loc:
            self.calibration_info()
            Wavelength_shift = self.Shot_info.Probe_wavelength - self.Probe_pix_loc*self.Shot_info.Wavelength_per_pixel
        else:
            Wavelength_shift = self.Probe_center - int(self.Data_image.shape[0]/2) * self.Shot_info.Wavelength_per_pixel

        Wavelength_axis += Wavelength_shift

        return Wavelength_axis

    def illustrate_scattering_region(self):
        """
        Visualizes the scattering region on the data image for a given shot.

        This method creates a plot of the data image with the scattering region highlighted.
        It also overlays vertical and horizontal dashed lines to indicate the probe start time and probe wavelength, respectively.
        The scattering region is determined based on the signal time and wavelength ranges specified in `self.Shot_info`.
        This visualization should be used to update the necessary parameters to select the correct scattering region.
        """
        xy = (self.Shot_info.Signal_time[0], self.Shot_info.Signal_wavelength[0])
        width = self.Shot_info.Signal_time[1] - self.Shot_info.Signal_time[0]
        height = self.Shot_info.Signal_wavelength[1] - self.Shot_info.Signal_wavelength[0]
        box = Rectangle(xy, width, height, fill=False, color='white', linewidth=2, alpha=0.65, label='Scattering region')

        Signal_time_pix = [np.argmin(np.abs(self.Time_axis - self.Shot_info.Signal_time[0])), 
                           np.argmin(np.abs(self.Time_axis - self.Shot_info.Signal_time[1]))]
        Signal_wavelength_pix = [np.argmin(np.abs(self.Wavelength_axis - self.Shot_info.Signal_wavelength[0])), 
                                 np.argmin(np.abs(self.Wavelength_axis - self.Shot_info.Signal_wavelength[1]))]
        Scattering_region = self.Data_image[np.min(Signal_wavelength_pix):np.max(Signal_wavelength_pix), Signal_time_pix[0]:Signal_time_pix[1]]

        fig, axs = plt.subplots(figsize=(6, 7))
        axs.imshow(self.Data_image, cmap='inferno', origin='lower', vmin=1, vmax=0.9*np.max(Scattering_region), extent=[self.Time_axis[0], self.Time_axis[-1], self.Wavelength_axis[0], self.Wavelength_axis[-1]])
        axs.add_patch(box)
        axs.axvline(self.Shot_info.Probe_start, color='red', linestyle='--', label='Probe start')
        axs.axhline(self.Shot_info.Probe_wavelength, color='white', linestyle='--', label='Probe wavelength')
        axs.set_aspect('auto', adjustable='box')
        plt.legend()
        plt.suptitle(f's{self.Shot_info.Shot_number} {self.Shot_info.Diagnostic} Scattering Region')
        plt.show()

class Data_extraction:
    """
    Extracts and processes the scattering signal from the data image.

    This class isolates the region of interest, removes background, and bins the data according to the temporal resolution.

    Parameters
    ----------
    Shot_info : Shot_information
        Instance containing shot and system parameters.
    Data_info : Data_calibration
        Instance containing calibrated data and axes.

    Attributes
    ----------
    Scattering_times : np.ndarray
        Array of mean times for each temporal bin (ns).
    Wavelength_axis : np.ndarray
        Cropped wavelength axis corresponding to the scattering region.
    Scattering_intensities : np.ndarray
        Array of mean normalized intensities for each bin.
    Intensity_per_errors : np.ndarray
        Array of relative intensity errors for each bin (Signal_error/Signal_intensity).
    """
    def __init__(self, Shot_info, Data_info):
        self.Shot_info = Shot_info
        self.Data_info = Data_info

        self.get_scattering_strips()
        self.bin_data()

    def get_scattering_strips(self, polyorder=2, plot=False):
        """
        Extracts the scattering signal from the data image.

        The method isolates the region of interest in the data image based on specified time and wavelength ranges.
        A rough background removal is performed by fitting a polynomial to the edge pixels of each time slice of the
        scattering region.

        Parameters
        ----------
        polyorder : int
            The degree of the polynomial to fit to the background.
        plot: bool (optional)
            If True, plots the original and background-removed scattering regions. Default is False.

        Attributes
        ----------
        Time_axis : np.ndarray
            Cropped time axis corresponding to the scattering region (ns).
        Wavelength_axis : np.ndarray
            Cropped wavelength axis corresponding to the scattering region.
        Scattering_strips : np.ndarray
            2D numpy array of background-subtracted scattering data.

        """
        Signal_time_pix = [np.argmin(np.abs(self.Data_info.Time_axis - self.Shot_info.Signal_time[0])), 
                           np.argmin(np.abs(self.Data_info.Time_axis - self.Shot_info.Signal_time[1]))]
        Signal_wavelength_pix = [np.argmin(np.abs(self.Data_info.Wavelength_axis - self.Shot_info.Signal_wavelength[0])), 
                                 np.argmin(np.abs(self.Data_info.Wavelength_axis - self.Shot_info.Signal_wavelength[1]))]
        Scattering_region = self.Data_info.Data_image[np.min(Signal_wavelength_pix):np.max(Signal_wavelength_pix), Signal_time_pix[0]:Signal_time_pix[1]]
        self.Time_axis = self.Data_info.Time_axis[Signal_time_pix[0]:Signal_time_pix[1]]
        self.Wavelength_axis = self.Data_info.Wavelength_axis[np.min(Signal_wavelength_pix):np.max(Signal_wavelength_pix)]

        ## Fit a polynomial to the background and subtract
        Npix = np.arange(Scattering_region.shape[0])
        edge_width = max(10, int(0.2 * Scattering_region.shape[0]))  # Use 20% of pixels at each edge, at least 10 pixels
        Signals = np.zeros_like(Scattering_region)
        for f in range(Scattering_region.shape[1]):
            Signal = Scattering_region[:, f]
            ## Use both edges of signal for background estimation
            Background_npix = np.concatenate((Npix[:edge_width], Npix[-edge_width:]))
            Background_signal = np.concatenate((Signal[:edge_width], Signal[-edge_width:]))
            if np.max(Background_signal) >= 0.2*np.max(Signal):
                print(f'Warning: Background signal may be too high at time {self.Time_axis[f]} ns')
            ## Fit a nth degree polynomial to the background
            coeffs = np.polyfit(Background_npix, Background_signal, deg=polyorder)
            Background_fit = np.polyval(coeffs, Npix)
            Signals[:, f] = Signal - Background_fit
        self.Scattering_strips = Signals

        if plot:
            fig, axs = plt.subplots(1, 2, sharey=True)
            axs[0].imshow(Scattering_region, cmap='inferno', origin='lower', extent=[self.Time_axis[0], self.Time_axis[-1], self.Wavelength_axis[0], self.Wavelength_axis[-1]])
            axs[0].set_title('Original scattering region')
            axs[1].imshow(self.Scattering_strips, cmap='inferno', origin='lower', extent=[self.Time_axis[0], self.Time_axis[-1], self.Wavelength_axis[0], self.Wavelength_axis[-1]])
            axs[1].set_title('Background removed scattering')
            axs[0].set_ylabel('Wavelength (nm)')
            for ax in axs.flat:
                ax.set_aspect('auto', adjustable='box')
                ax.set_xlabel('Time (ns)')

    def bin_data(self):
        """
        Bins and averages the scattering data according to the temporal resolution.
        
        This method divides the scattering data into temporal bins based on the specified temporal resolution,
        normalizes the intensities within each bin, and computes the mean intensity, standard deviation, and
        relative error for each bin.
        
        Attributes
        ----------
        Scattering_times : np.ndarray
            Array of mean times for each temporal bin (ns).
        Scattering_intensities : np.ndarray
            Array of mean normalized intensities for each bin.
        Intensity_per_errors : np.ndarray
            Array of relative intensity errors for each bin (Signal_error/Signal_intensity).
        """
        ## Get temporal resolution
        Temporal_resolution_pixels = int(self.Shot_info.Temporal_resolution/self.Data_info.Time_per_pixel)
        print(Temporal_resolution_pixels)
        
        ## Vectorized binning and averaging
        Scattering_times = []
        Scattering_intensities = []
        Intensity_per_errors = []
        num_bins = np.shape(self.Scattering_strips)[1] // Temporal_resolution_pixels
        for i in range(num_bins):
            idx_start = i * Temporal_resolution_pixels
            idx_end = idx_start + Temporal_resolution_pixels - 1
            bin_intensities = self.Scattering_strips[:, idx_start:idx_end] / np.nanmax(self.Scattering_strips[:, idx_start:idx_end])
            bin_times = self.Time_axis[idx_start:idx_end]
            time = np.mean(bin_times)
            Intensity = np.nanmean(bin_intensities, axis=1)
            Intensity_error = np.nanstd(bin_intensities, axis=1)
            Intensity_per_error = np.abs(Intensity_error / Intensity)
            Intensity /= np.max(Intensity)

            Scattering_times.append(time)
            Scattering_intensities.append(Intensity)
            Intensity_per_errors.append(Intensity_per_error)
        print('Due to the temporal resolution, the scattering signal from {:.4g} to {:.4g} ns has been omitted'.format(self.Time_axis[int((num_bins) * Temporal_resolution_pixels)], self.Time_axis[-1]))

        self.Scattering_times = np.array(Scattering_times)
        self.Scattering_intensities = np.array(Scattering_intensities)
        self.Intensity_per_errors = np.array(Intensity_per_errors)  
        return

if __name__ == "__main__":
    #%%
    ## Import data
    ###############################################################
    ##                                                           ##
    ##                        DATA TO INPUT                      ##
    ##                                                           ##
    ###############################################################

    ## Define the shot day, shot number, and diagnostic
    Shot_day = 'OMEGA_Jun2023'
    Shot_number = 108617

    ## If using TDYNO_NLUF Box account, User as required in Parent_loc
    User = 'hpoole'

    ## If you want to save output figures and info
    ## NB: I haven't yet implemented this, so it will not save anything
    Save_bool = True

    ## If you have, and want to use the calibration files
    Calibration_bool = True

    ###############################################################

    ###############################################################
    ##                                                           ##
    ##                      FILE LOCATIONS                       ##
    ##                                                           ##
    ###############################################################
    Global_loc = os.path.join('/', 'Users', User, 'Library', 'CloudStorage', 'Box-Box', 'TDYNO_NLUF', 'OMEGA', Shot_day, 'Data')
    Parent_loc = os.path.join(Global_loc, str(Shot_number), 'IAW')

    ## Define the data file location
    Data_file_loc = os.path.join(Parent_loc, f'iaw_s{Shot_number}.hdf')
    ## Check if the data file exists
    if not os.path.exists(Data_file_loc):
        print(f"Data file not found: {Data_file_loc}")
        sys.exit(1)

    if Calibration_bool:
        ## Define the alignment calibration file location
        ## This file is generated by the calibration script
        Calibration_file_loc = os.path.join(Global_loc, '0', 'IAW', 'IAW_calibration_info.txt')
        ## Check if the file exists
        if not os.path.exists(Calibration_file_loc):
            print(f"Calibration file not found: {Calibration_file_loc}")
            sys.exit(1)
    ###############################################################

    #%%
    ###############################################################
    ##                                                           ##
    ##                    PERFORM ANALYSIS                       ##
    ##                                                           ##
    ###############################################################
    
    ## Create the shot information object
    Shot_info = Shot_information(Shot_day, Shot_number)

    ## Extract data image and perform calibration
    Data_info = Data_calibration(Shot_info, Parent_loc, Data_file_loc, Calibration_file_loc=Calibration_file_loc)

    ## Generate the scattering data output
    Data_output = Data_extraction(Shot_info, Data_info)

    ###############################################################
    #%%
    ## Plot the scattering intensities 
    Timings, Wavelengths, Scattering_intensities, Intensity_per_errors = Data_output.Scattering_times, Data_output.Wavelength_axis, Data_output.Scattering_intensities, Data_output.Intensity_per_errors
    Scattering_errors = np.abs(Scattering_intensities * Intensity_per_errors)

    fig, axs = plt.subplots(figsize=(7, 6))
    cmap = plt.cm.jet(np.linspace(0, 1, len(Timings)))  
    for i in range(len(Timings)):
        axs.errorbar(Wavelengths, Scattering_intensities[i], yerr=Scattering_errors[i], color=cmap[i],
        capsize=4, barsabove=True, linestyle='None', marker='D', markersize=2,
        alpha=0.5)
        axs.plot(Wavelengths, Scattering_intensities[i], color=cmap[i])
    sm = plt.cm.ScalarMappable(cmap='jet', norm=plt.Normalize(vmin=Timings[0], vmax=Timings[-1]))
    plt.colorbar(sm, ax=axs, label='Time (ns)')
    plt.ylabel('Normalized Signal Intensity')
    plt.xlabel('Wavelength (nm)')
    plt.suptitle(f's{Shot_number} {Shot_info.Diagnostic} Thomson Scattering')
    plt.show()

    quit()
    #%%
    ## Comparing to old data (IGNORE THIS UNLESS HANNAH :) )    

    import glob
    Old_loc = f'/Users/hpoole/Documents/TDYNO/OMEGA/OMEGA_Jun2023/Data/{Shot_number}/IAW/Scattering_strips'
    txt_files = sorted(glob.glob(os.path.join(Old_loc, "*.txt")))

    def read_txt(file):
        Raw_data = np.genfromtxt(file)
        raw_lambda, raw_I, Raw_per_err = Raw_data[:, 0], Raw_data[:, 1], Raw_data[:, 2]
        raw_err = raw_I * Raw_per_err
        return [raw_lambda, raw_I, raw_err]

    cmap = plt.cm.jet(np.linspace(0, 1, len(Data_output.Scattering_times)))  
    for i in range(len(Data_output.Scattering_times)):
        fig, axs = plt.subplots()
        axs.errorbar(Wavelengths, Scattering_intensities[i], yerr=Scattering_errors[i], color=cmap[i],
        capsize=4, barsabove=True, linestyle='None', marker='D', markersize=2,
        alpha=0.5)
        axs.plot(Wavelengths, Scattering_intensities[i], color=cmap[i])

        old_info = read_txt(txt_files[i])
        axs.errorbar(old_info[0], old_info[1], yerr=np.abs(old_info[2]), color='k',
        capsize=4, barsabove=True, linestyle='None', marker='D', markersize=2,
        alpha=0.15)
        axs.plot(old_info[0], old_info[1], color='k')
        plt.ylabel('Normalized Signal Intensity')
        plt.xlabel('Wavelength (nm)')
        plt.suptitle(f's{Shot_number} {Shot_info.Diagnostic} Scattering at {Data_output.Scattering_times[i]:.2f} ns')
        plt.show()